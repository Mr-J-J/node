##我为什么要打扰？

编写我自己的 KNX 协议栈的主要原因是我找不到能够正确处理状态管理的*强大*访问层。
连接往往总是失败；考虑 flakey Wi-Fi、RRR（顽固重启路由器）、不良业力，它一直在发生。 KNX 访问层应该具有*弹性*，并且能够在需要时恢复。

此外，虽然看似无辜，但在同一组地址上对 *read()* 和 *write()* 的连续调用要么会*混淆*您的 KNX IP 路由器，要么*返回不连贯的结果*。
KNXnet/IP 使用 **UDP** 套接字，从程序员的角度来看，这并不理想。数据包可以任意顺序来来去去；很少有库提供协调状态并确保**稳定可靠的连接**的稳健性。

据我所知，这个库是唯一可以处理隧道请求的*序列化*的库，您的程序将拥有*强大且可靠的* KNX 连接。尝试在连接时切换 Wi-Fi 或断开以太网电缆；图书馆将检测到这一点并在网络访问恢复时重新连接:)

```
10 月 27 日 15:44:24 - [信息] 开始流程
10 月 27 日 15:44:24 - [info] [knx-controller:9ab91ab8.547938] KNX：成功连接到 224.0.23.12:3671
10 月 27 日 15:44:24 - [info] [knx-controller:9ab91ab8.547938] GroupValue_Read {"srcphy":"15.15.15","dstgad":"0/0/15"}
...
10 月 27 日 15:44:54 - [info] [knx-controller:9ab91ab8.547938] KNX 连接错误：等待 CONNECTIONSTATE_RESPONSE 超时
10 月 27 日 15:45:36 - [info] [knx-controller:9ab91ab8.547938] KNX：成功连接到 224.0.23.12:3671
10 月 27 日 15:45:36 - [info] [knx-in:input] GroupValue_Read {"srcphy":"15.15.15","dstgad":"0/0/15"}
```


## 关于弹性的说明

基本上有*两种*方法通过 UDP/IP 与 KNX 通信：

- **隧道**实际上是具有连接状态的 UDP **单播**（本质上模仿 TCP），因此我们可以通过 CONNECT_REQUEST 与路由器或接口建立会话 ID。这使我们能够定期检查连接的健康状况（使用 CONNECTIONSTATE_REQUESTs）并处理重试、确认等。这里的缺点是 KNXnet/IP 缺乏服务发现机制，因此您需要指定路由器/接口端点 IP 地址和端口。

- **路由**是一个普通的 UDP 多播传输*没有任何连接或可靠性语义* - 这使得检测丢弃的数据包变得更加困难，例如由于网络拥塞。多播方法适用于仅专用于 KNX 流量的有线高速（例如以太网）网段。众所周知，KNX/TP1 的带宽比 LAN 慢几个数量级，但是当您通过 VPN 连接时，情况并非如此！ *实际上，您的网络肯定会丢弃一些数据包*。多播的优点是它不需要配置，只要将 IP 路由器配置为默认的 KNX 多播地址 (224.0.23.12)

- 最后，该库允许使用**混合**方法，即充分利用上述两种方法：您可以使用带有**隧道**连接的**多播**传输，以确保可靠通信。 *很遗憾，这偏离了官方的 KNXnet/IP 规范*，因此与某些 IP 路由器不兼容。您可以通过在构造新的 Connection 对象时启用 `forceTunneling` 选项来启用此“混合模式”，如下所示：
```js
var connection = new knx.Connection( {
  // 使用多播隧道-并非所有路由器都支持！
  forceTunneling: true,
...
});
```
